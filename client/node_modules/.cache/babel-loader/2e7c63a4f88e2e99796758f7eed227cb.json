{"ast":null,"code":"var ethJSABI = require(\"ethjs-abi\");\n\nvar BlockchainUtils = require(\"truffle-blockchain-utils\");\n\nvar Web3 = require(\"web3\");\n\nvar StatusError = require(\"./statuserror.js\"); // For browserified version. If browserify gave us an empty version,\n// look for the one provided by the user.\n\n\nif (typeof Web3 == \"object\" && Object.keys(Web3).length == 0) {\n  Web3 = global.Web3;\n}\n\nvar contract = function (module) {\n  // Planned for future features, logging, etc.\n  function Provider(provider) {\n    this.provider = provider;\n  }\n\n  Provider.prototype.send = function () {\n    return this.provider.send.apply(this.provider, arguments);\n  };\n\n  Provider.prototype.sendAsync = function () {\n    return this.provider.sendAsync.apply(this.provider, arguments);\n  };\n\n  var BigNumber = new Web3().toBigNumber(0).constructor;\n  var Utils = {\n    is_object: function is_object(val) {\n      return typeof val == \"object\" && !Array.isArray(val);\n    },\n    is_big_number: function is_big_number(val) {\n      if (typeof val != \"object\") return false; // Instanceof won't work because we have multiple versions of Web3.\n\n      try {\n        new BigNumber(val);\n        return true;\n      } catch (e) {\n        return false;\n      }\n    },\n    decodeLogs: function decodeLogs(C, instance, logs) {\n      return logs.map(function (log) {\n        var logABI = C.events[log.topics[0]];\n\n        if (logABI == null) {\n          return null;\n        } // This function has been adapted from web3's SolidityEvent.decode() method,\n        // and built to work with ethjs-abi.\n\n\n        var copy = Utils.merge({}, log);\n\n        function partialABI(fullABI, indexed) {\n          var inputs = fullABI.inputs.filter(function (i) {\n            return i.indexed === indexed;\n          });\n          var partial = {\n            inputs: inputs,\n            name: fullABI.name,\n            type: fullABI.type,\n            anonymous: fullABI.anonymous\n          };\n          return partial;\n        }\n\n        var argTopics = logABI.anonymous ? copy.topics : copy.topics.slice(1);\n        var indexedData = \"0x\" + argTopics.map(function (topics) {\n          return topics.slice(2);\n        }).join(\"\");\n        var indexedParams = ethJSABI.decodeEvent(partialABI(logABI, true), indexedData);\n        var notIndexedData = copy.data;\n        var notIndexedParams = ethJSABI.decodeEvent(partialABI(logABI, false), notIndexedData);\n        copy.event = logABI.name;\n        copy.args = logABI.inputs.reduce(function (acc, current) {\n          var val = indexedParams[current.name];\n\n          if (val === undefined) {\n            val = notIndexedParams[current.name];\n          }\n\n          acc[current.name] = val;\n          return acc;\n        }, {});\n        Object.keys(copy.args).forEach(function (key) {\n          var val = copy.args[key]; // We have BN. Convert it to BigNumber\n\n          if (val.constructor.isBN) {\n            copy.args[key] = C.web3.toBigNumber(\"0x\" + val.toString(16));\n          }\n        });\n        delete copy.data;\n        delete copy.topics;\n        return copy;\n      }).filter(function (log) {\n        return log != null;\n      });\n    },\n    promisifyFunction: function promisifyFunction(fn, C) {\n      var self = this;\n      return function () {\n        var instance = this;\n        var args = Array.prototype.slice.call(arguments);\n        var tx_params = {};\n        var last_arg = args[args.length - 1]; // It's only tx_params if it's an object and not a BigNumber.\n\n        if (Utils.is_object(last_arg) && !Utils.is_big_number(last_arg)) {\n          tx_params = args.pop();\n        }\n\n        tx_params = Utils.merge(C.class_defaults, tx_params);\n        return C.detectNetwork().then(function () {\n          return new Promise(function (accept, reject) {\n            var callback = function callback(error, result) {\n              if (error != null) {\n                reject(error);\n              } else {\n                accept(result);\n              }\n            };\n\n            args.push(tx_params, callback);\n            fn.apply(instance.contract, args);\n          });\n        });\n      };\n    },\n    synchronizeFunction: function synchronizeFunction(fn, instance, C) {\n      var self = this;\n      return function () {\n        var args = Array.prototype.slice.call(arguments);\n        var tx_params = {};\n        var last_arg = args[args.length - 1]; // It's only tx_params if it's an object and not a BigNumber.\n\n        if (Utils.is_object(last_arg) && !Utils.is_big_number(last_arg)) {\n          tx_params = args.pop();\n        }\n\n        tx_params = Utils.merge(C.class_defaults, tx_params);\n        return C.detectNetwork().then(function () {\n          return new Promise(function (accept, reject) {\n            var callback = function callback(error, tx) {\n              if (error != null) {\n                reject(error);\n                return;\n              }\n\n              var timeout;\n\n              if (C.synchronization_timeout === 0 || C.synchronization_timeout !== undefined) {\n                timeout = C.synchronization_timeout;\n              } else {\n                timeout = 240000;\n              }\n\n              var start = new Date().getTime();\n\n              var make_attempt = function make_attempt() {\n                C.web3.eth.getTransactionReceipt(tx, function (err, receipt) {\n                  if (err && !err.toString().includes('unknown transaction')) {\n                    return reject(err);\n                  } // Reject on transaction failures, accept otherwise\n                  // Handles \"0x00\" or hex 0\n\n\n                  if (receipt != null) {\n                    if (parseInt(receipt.status, 16) == 0) {\n                      var statusError = new StatusError(tx_params, tx, receipt);\n                      return reject(statusError);\n                    } else {\n                      return accept({\n                        tx: tx,\n                        receipt: receipt,\n                        logs: Utils.decodeLogs(C, instance, receipt.logs)\n                      });\n                    }\n                  }\n\n                  if (timeout > 0 && new Date().getTime() - start > timeout) {\n                    return reject(new Error(\"Transaction \" + tx + \" wasn't processed in \" + timeout / 1000 + \" seconds!\"));\n                  }\n\n                  setTimeout(make_attempt, 1000);\n                });\n              };\n\n              make_attempt();\n            };\n\n            args.push(tx_params, callback);\n            fn.apply(self, args);\n          });\n        });\n      };\n    },\n    merge: function merge() {\n      var merged = {};\n      var args = Array.prototype.slice.call(arguments);\n\n      for (var i = 0; i < args.length; i++) {\n        var object = args[i];\n        var keys = Object.keys(object);\n\n        for (var j = 0; j < keys.length; j++) {\n          var key = keys[j];\n          var value = object[key];\n          merged[key] = value;\n        }\n      }\n\n      return merged;\n    },\n    parallel: function parallel(arr, callback) {\n      callback = callback || function () {};\n\n      if (!arr.length) {\n        return callback(null, []);\n      }\n\n      var index = 0;\n      var results = new Array(arr.length);\n      arr.forEach(function (fn, position) {\n        fn(function (err, result) {\n          if (err) {\n            callback(err);\n\n            callback = function callback() {};\n          } else {\n            index++;\n            results[position] = result;\n\n            if (index >= arr.length) {\n              callback(null, results);\n            }\n          }\n        });\n      });\n    },\n    bootstrap: function bootstrap(fn) {\n      // Add our static methods\n      Object.keys(fn._static_methods).forEach(function (key) {\n        fn[key] = fn._static_methods[key].bind(fn);\n      }); // Add our properties.\n\n      Object.keys(fn._properties).forEach(function (key) {\n        fn.addProp(key, fn._properties[key]);\n      });\n      return fn;\n    },\n    linkBytecode: function linkBytecode(bytecode, links) {\n      Object.keys(links).forEach(function (library_name) {\n        var library_address = links[library_name];\n        var regex = new RegExp(\"__\" + library_name + \"_+\", \"g\");\n        bytecode = bytecode.replace(regex, library_address.replace(\"0x\", \"\"));\n      });\n      return bytecode;\n    }\n  }; // Accepts a contract object created with web3.eth.contract.\n  // Optionally, if called without `new`, accepts a network_id and will\n  // create a new version of the contract abstraction with that network_id set.\n\n  function Contract(contract) {\n    var self = this;\n    var constructor = this.constructor;\n    this.abi = constructor.abi;\n\n    if (typeof contract == \"string\") {\n      var address = contract;\n      var contract_class = constructor.web3.eth.contract(this.abi);\n      contract = contract_class.at(address);\n    }\n\n    this.contract = contract; // Provision our functions.\n\n    for (var i = 0; i < this.abi.length; i++) {\n      var item = this.abi[i];\n\n      if (item.type == \"function\") {\n        if (item.constant == true) {\n          this[item.name] = Utils.promisifyFunction(contract[item.name], constructor);\n        } else {\n          this[item.name] = Utils.synchronizeFunction(contract[item.name], this, constructor);\n        }\n\n        this[item.name].call = Utils.promisifyFunction(contract[item.name].call, constructor);\n        this[item.name].sendTransaction = Utils.promisifyFunction(contract[item.name].sendTransaction, constructor);\n        this[item.name].request = contract[item.name].request;\n        this[item.name].estimateGas = Utils.promisifyFunction(contract[item.name].estimateGas, constructor);\n      }\n\n      if (item.type == \"event\") {\n        this[item.name] = contract[item.name];\n      }\n    }\n\n    this.sendTransaction = Utils.synchronizeFunction(function (tx_params, callback) {\n      if (typeof tx_params == \"function\") {\n        callback = tx_params;\n        tx_params = {};\n      }\n\n      tx_params.to = self.address;\n      constructor.web3.eth.sendTransaction.apply(constructor.web3.eth, [tx_params, callback]);\n    }, this, constructor);\n\n    this.send = function (value) {\n      return self.sendTransaction({\n        value: value\n      });\n    };\n\n    this.allEvents = contract.allEvents;\n    this.address = contract.address;\n    this.transactionHash = contract.transactionHash;\n  }\n\n  ;\n  Contract._static_methods = {\n    setProvider: function setProvider(provider) {\n      if (!provider) {\n        throw new Error(\"Invalid provider passed to setProvider(); provider is \" + provider);\n      }\n\n      var wrapped = new Provider(provider);\n      this.web3.setProvider(wrapped);\n      this.currentProvider = provider;\n    },\n    new: function _new() {\n      var self = this;\n\n      if (this.currentProvider == null) {\n        throw new Error(this.contractName + \" error: Please call setProvider() first before calling new().\");\n      }\n\n      var args = Array.prototype.slice.call(arguments);\n\n      if (!this.bytecode) {\n        throw new Error(this._json.contractName + \" error: contract binary not set. Can't deploy new instance.\");\n      }\n\n      return self.detectNetwork().then(function (network_id) {\n        // After the network is set, check to make sure everything's ship shape.\n        var regex = /__[^_]+_+/g;\n        var unlinked_libraries = self.binary.match(regex);\n\n        if (unlinked_libraries != null) {\n          unlinked_libraries = unlinked_libraries.map(function (name) {\n            // Remove underscores\n            return name.replace(/_/g, \"\");\n          }).sort().filter(function (name, index, arr) {\n            // Remove duplicates\n            if (index + 1 >= arr.length) {\n              return true;\n            }\n\n            return name != arr[index + 1];\n          }).join(\", \");\n          throw new Error(self.contractName + \" contains unresolved libraries. You must deploy and link the following libraries before you can deploy a new version of \" + self._json.contractName + \": \" + unlinked_libraries);\n        }\n      }).then(function () {\n        return new Promise(function (accept, reject) {\n          var contract_class = self.web3.eth.contract(self.abi);\n          var tx_params = {};\n          var last_arg = args[args.length - 1]; // It's only tx_params if it's an object and not a BigNumber.\n\n          if (Utils.is_object(last_arg) && !Utils.is_big_number(last_arg)) {\n            tx_params = args.pop();\n          } // Validate constructor args\n\n\n          var constructor = self.abi.filter(function (item) {\n            return item.type === 'constructor';\n          });\n\n          if (constructor.length && constructor[0].inputs.length !== args.length) {\n            throw new Error(self.contractName + \" contract constructor expected \" + constructor[0].inputs.length + \" arguments, received \" + args.length);\n          }\n\n          tx_params = Utils.merge(self.class_defaults, tx_params);\n\n          if (tx_params.data == null) {\n            tx_params.data = self.binary;\n          } // web3 0.9.0 and above calls new this callback twice.\n          // Why, I have no idea...\n\n\n          var intermediary = function intermediary(err, web3_instance) {\n            if (err != null) {\n              reject(err);\n              return;\n            }\n\n            if (err == null && web3_instance != null && web3_instance.address != null) {\n              accept(new self(web3_instance));\n            }\n          };\n\n          args.push(tx_params, intermediary);\n          contract_class.new.apply(contract_class, args);\n        });\n      });\n    },\n    at: function at(address) {\n      var self = this;\n\n      if (address == null || typeof address != \"string\" || address.length != 42) {\n        throw new Error(\"Invalid address passed to \" + this._json.contractName + \".at(): \" + address);\n      }\n\n      var contract = new this(address); // Add thennable to allow people opt into new recommended usage.\n\n      contract.then = function (fn) {\n        return self.detectNetwork().then(function (network_id) {\n          var instance = new self(address);\n          return new Promise(function (accept, reject) {\n            self.web3.eth.getCode(address, function (err, code) {\n              if (err) return reject(err);\n\n              if (!code || code.replace(\"0x\", \"\").replace(/0/g, \"\") === '') {\n                return reject(new Error(\"Cannot create instance of \" + self.contractName + \"; no code at address \" + address));\n              }\n\n              accept(instance);\n            });\n          });\n        }).then(fn);\n      };\n\n      return contract;\n    },\n    deployed: function deployed() {\n      var self = this;\n      return self.detectNetwork().then(function () {\n        // We don't have a network config for the one we found\n        if (self._json.networks[self.network_id] == null) {\n          throw new Error(self.contractName + \" has not been deployed to detected network (network/artifact mismatch)\");\n        } // If we found the network but it's not deployed\n\n\n        if (!self.isDeployed()) {\n          throw new Error(self.contractName + \" has not been deployed to detected network (\" + self.network_id + \")\");\n        }\n\n        return new self(self.address);\n      });\n    },\n    defaults: function defaults(class_defaults) {\n      if (this.class_defaults == null) {\n        this.class_defaults = {};\n      }\n\n      if (class_defaults == null) {\n        class_defaults = {};\n      }\n\n      var self = this;\n      Object.keys(class_defaults).forEach(function (key) {\n        var value = class_defaults[key];\n        self.class_defaults[key] = value;\n      });\n      return this.class_defaults;\n    },\n    hasNetwork: function hasNetwork(network_id) {\n      return this._json.networks[network_id + \"\"] != null;\n    },\n    isDeployed: function isDeployed() {\n      if (this.network_id == null) {\n        return false;\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        return false;\n      }\n\n      return !!this.network.address;\n    },\n    detectNetwork: function detectNetwork() {\n      var self = this;\n      return new Promise(function (accept, reject) {\n        // Try to detect the network we have artifacts for.\n        if (self.network_id) {\n          // We have a network id and a configuration, let's go with it.\n          if (self.networks[self.network_id] != null) {\n            return accept(self.network_id);\n          }\n        }\n\n        self.web3.version.getNetwork(function (err, result) {\n          if (err) return reject(err);\n          var network_id = result.toString(); // If we found the network via a number, let's use that.\n\n          if (self.hasNetwork(network_id)) {\n            self.setNetwork(network_id);\n            return accept();\n          } // Otherwise, go through all the networks that are listed as\n          // blockchain uris and see if they match.\n\n\n          var uris = Object.keys(self._json.networks).filter(function (network) {\n            return network.indexOf(\"blockchain://\") == 0;\n          });\n          var matches = uris.map(function (uri) {\n            return BlockchainUtils.matches.bind(BlockchainUtils, uri, self.web3.currentProvider);\n          });\n          Utils.parallel(matches, function (err, results) {\n            if (err) return reject(err);\n\n            for (var i = 0; i < results.length; i++) {\n              if (results[i]) {\n                self.setNetwork(uris[i]);\n                return accept();\n              }\n            } // We found nothing. Set the network id to whatever the provider states.\n\n\n            self.setNetwork(network_id);\n            accept();\n          });\n        });\n      });\n    },\n    setNetwork: function setNetwork(network_id) {\n      if (!network_id) return;\n      this.network_id = network_id + \"\";\n    },\n    // Overrides the deployed address to null.\n    // You must call this explicitly so you don't inadvertently do this otherwise.\n    resetAddress: function resetAddress() {\n      delete this.network.address;\n    },\n    link: function link(name, address) {\n      var self = this;\n\n      if (typeof name == \"function\") {\n        var contract = name;\n\n        if (contract.isDeployed() == false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n        Object.keys(contract.events).forEach(function (topic) {\n          self.network.events[topic] = contract.events[topic];\n        });\n        return;\n      }\n\n      if (typeof name == \"object\") {\n        var obj = name;\n        Object.keys(obj).forEach(function (name) {\n          var a = obj[name];\n          self.link(name, a);\n        });\n        return;\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        this._json.networks[this.network_id] = {\n          events: {},\n          links: {}\n        };\n      }\n\n      this.network.links[name] = address;\n    },\n    // Note, this function can be called with two input types:\n    // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n    // 2. network id; this will clone the contract and set a specific network id upon cloning.\n    clone: function clone(json) {\n      var self = this;\n      json = json || {};\n\n      var temp = function TruffleContract() {\n        this.constructor = temp;\n        return Contract.apply(this, arguments);\n      };\n\n      temp.prototype = Object.create(self.prototype);\n      var network_id; // If we have a network id passed\n\n      if (typeof json != \"object\") {\n        network_id = json;\n        json = self._json;\n      }\n\n      json = Utils.merge({}, self._json || {}, json);\n      temp._static_methods = this._static_methods;\n      temp._properties = this._properties;\n      temp._property_values = {};\n      temp._json = json;\n      Utils.bootstrap(temp);\n      temp.web3 = new Web3();\n      temp.class_defaults = temp.prototype.defaults || {};\n\n      if (network_id) {\n        temp.setNetwork(network_id);\n      } // Copy over custom key/values to the contract class\n\n\n      Object.keys(json).forEach(function (key) {\n        if (key.indexOf(\"x-\") != 0) return;\n        temp[key] = json[key];\n      });\n      return temp;\n    },\n    addProp: function addProp(key, fn) {\n      var self = this;\n\n      var getter = function getter() {\n        if (fn.get != null) {\n          return fn.get.call(self);\n        }\n\n        return self._property_values[key] || fn.call(self);\n      };\n\n      var setter = function setter(val) {\n        if (fn.set != null) {\n          fn.set.call(self, val);\n          return;\n        } // If there's not a setter, then the property is immutable.\n\n\n        throw new Error(key + \" property is immutable\");\n      };\n\n      var definition = {};\n      definition.enumerable = false;\n      definition.configurable = false;\n      definition.get = getter;\n      definition.set = setter;\n      Object.defineProperty(this, key, definition);\n    },\n    toJSON: function toJSON() {\n      return this._json;\n    }\n  }; // Getter functions are scoped to Contract object.\n\n  Contract._properties = {\n    contract_name: {\n      get: function get() {\n        return this.contractName;\n      },\n      set: function set(val) {\n        this.contractName = val;\n      }\n    },\n    contractName: {\n      get: function get() {\n        return this._json.contractName || \"Contract\";\n      },\n      set: function set(val) {\n        this._json.contractName = val;\n      }\n    },\n    abi: {\n      get: function get() {\n        return this._json.abi;\n      },\n      set: function set(val) {\n        this._json.abi = val;\n      }\n    },\n    network: function network() {\n      var network_id = this.network_id;\n\n      if (network_id == null) {\n        throw new Error(this.contractName + \" has no network id set, cannot lookup artifact data. Either set the network manually using \" + this.contractName + \".setNetwork(), run \" + this.contractName + \".detectNetwork(), or use new(), at() or deployed() as a thenable which will detect the network automatically.\");\n      } // TODO: this might be bad; setting a value on a get.\n\n\n      if (this._json.networks[network_id] == null) {\n        throw new Error(this.contractName + \" has no network configuration for its current network id (\" + network_id + \").\");\n      }\n\n      var returnVal = this._json.networks[network_id]; // Normalize output\n\n      if (returnVal.links == null) {\n        returnVal.links = {};\n      }\n\n      if (returnVal.events == null) {\n        returnVal.events = {};\n      }\n\n      return returnVal;\n    },\n    networks: function networks() {\n      return this._json.networks;\n    },\n    address: {\n      get: function get() {\n        var address = this.network.address;\n\n        if (address == null) {\n          throw new Error(\"Cannot find deployed address: \" + this.contractName + \" not deployed or address not set.\");\n        }\n\n        return address;\n      },\n      set: function set(val) {\n        if (val == null) {\n          throw new Error(\"Cannot set deployed address; malformed value: \" + val);\n        }\n\n        var network_id = this.network_id;\n\n        if (network_id == null) {\n          throw new Error(this.contractName + \" has no network id set, cannot lookup artifact data. Either set the network manually using \" + this.contractName + \".setNetwork(), run \" + this.contractName + \".detectNetwork(), or use new(), at() or deployed() as a thenable which will detect the network automatically.\");\n        } // Create a network if we don't have one.\n\n\n        if (this._json.networks[network_id] == null) {\n          this._json.networks[network_id] = {\n            events: {},\n            links: {}\n          };\n        } // Finally, set the address.\n\n\n        this.network.address = val;\n      }\n    },\n    transactionHash: {\n      get: function get() {\n        var transactionHash = this.network.transactionHash;\n\n        if (transactionHash === null) {\n          throw new Error(\"Could not find transaction hash for \" + this.contractName);\n        }\n\n        return transactionHash;\n      },\n      set: function set(val) {\n        this.network.transactionHash = val;\n      }\n    },\n    links: function links() {\n      if (!this.network_id) {\n        throw new Error(this.contractName + \" has no network id set, cannot lookup artifact data. Either set the network manually using \" + this.contractName + \".setNetwork(), run \" + this.contractName + \".detectNetwork(), or use new(), at() or deployed() as a thenable which will detect the network automatically.\");\n      }\n\n      if (this._json.networks[this.network_id] == null) {\n        return {};\n      }\n\n      return this.network.links || {};\n    },\n    events: function events() {\n      // helper web3; not used for provider\n      var web3 = new Web3();\n      var events;\n\n      if (this._json.networks[this.network_id] == null) {\n        events = {};\n      } else {\n        events = this.network.events || {};\n      } // Merge abi events with whatever's returned.\n\n\n      var abi = this.abi;\n      abi.forEach(function (item) {\n        if (item.type != \"event\") return;\n        var signature = item.name + \"(\";\n        item.inputs.forEach(function (input, index) {\n          signature += input.type;\n\n          if (index < item.inputs.length - 1) {\n            signature += \",\";\n          }\n        });\n        signature += \")\";\n        var topic = web3.sha3(signature);\n        events[topic] = item;\n      });\n      return events;\n    },\n    binary: function binary() {\n      return Utils.linkBytecode(this.bytecode, this.links);\n    },\n    deployedBinary: function deployedBinary() {\n      return Utils.linkBytecode(this.deployedBytecode, this.links);\n    },\n    // deprecated; use bytecode\n    unlinked_binary: {\n      get: function get() {\n        return this.bytecode;\n      },\n      set: function set(val) {\n        this.bytecode = val;\n      }\n    },\n    // alias for unlinked_binary; unlinked_binary will eventually be deprecated\n    bytecode: {\n      get: function get() {\n        return this._json.bytecode;\n      },\n      set: function set(val) {\n        this._json.bytecode = val;\n      }\n    },\n    deployedBytecode: {\n      get: function get() {\n        var code = this._json.deployedBytecode;\n\n        if (code.indexOf(\"0x\") != 0) {\n          code = \"0x\" + code;\n        }\n\n        return code;\n      },\n      set: function set(val) {\n        var code = val;\n\n        if (val.indexOf(\"0x\") != 0) {\n          code = \"0x\" + code;\n        }\n\n        this._json.deployedBytecode = code;\n      }\n    },\n    sourceMap: {\n      get: function get() {\n        return this._json.sourceMap;\n      },\n      set: function set(val) {\n        this._json.sourceMap = val;\n      }\n    },\n    deployedSourceMap: {\n      get: function get() {\n        return this._json.deployedSourceMap;\n      },\n      set: function set(val) {\n        this._json.deployedSourceMap = val;\n      }\n    },\n    source: {\n      get: function get() {\n        return this._json.source;\n      },\n      set: function set(val) {\n        this._json.source = val;\n      }\n    },\n    sourcePath: {\n      get: function get() {\n        return this._json.sourcePath;\n      },\n      set: function set(val) {\n        this._json.sourcePath = val;\n      }\n    },\n    legacyAST: {\n      get: function get() {\n        return this._json.legacyAST;\n      },\n      set: function set(val) {\n        this._json.legacyAST = val;\n      }\n    },\n    ast: {\n      get: function get() {\n        return this._json.ast;\n      },\n      set: function set(val) {\n        this._json.ast = val;\n      }\n    },\n    compiler: {\n      get: function get() {\n        return this._json.compiler;\n      },\n      set: function set(val) {\n        this._json.compiler = val;\n      }\n    },\n    // Deprecated\n    schema_version: function schema_version() {\n      return this.schemaVersion;\n    },\n    schemaVersion: function schemaVersion() {\n      return this._json.schemaVersion;\n    },\n    // deprecated\n    updated_at: function updated_at() {\n      return this.updatedAt;\n    },\n    updatedAt: function updatedAt() {\n      try {\n        return this.network.updatedAt || this._json.updatedAt;\n      } catch (e) {\n        return this._json.updatedAt;\n      }\n    }\n  };\n  Utils.bootstrap(Contract);\n  module.exports = Contract;\n  return Contract;\n}(module || {});","map":null,"metadata":{},"sourceType":"script"}